class_name Bullet extends Node3D

## Bullets handle the calculation of whether a shot actually lands, how much
## damage that shot does, and the actual 3D display of the bullet's flight
## path on screen. They are generated by Gun objects, and should be passed a
## trajectory by the gun that created them to be able to do what they ned
## to do

@export var damage = 10
@export var speed = 100

var real_start_pos : Vector3 = Vector3(0, 0, 0)
var visual_start_pos : Vector3 = Vector3(0, 0, 0)
var end_pos : Vector3 = Vector3(0, 0, 0)
var fired = false

# The character and gun that fired this bullet
var origin_gun : Gun = null
var origin_character : Character = null

@onready var initial_shot_raycast = $InitialShotRaycast

@export var successful_impact_particle_scene : PackedScene
@export var unsuccessful_impact_particle_scene : PackedScene

@export var rpg_event_modifiers : Array[RPGEventModifier] = []


# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta):
	if fired:
		visual_travel(delta)


func visual_travel(delta):
	look_at(end_pos)
	var distance_traveled = speed*delta
	if position.distance_to(end_pos) < distance_traveled:
		queue_free()
	else:
		var direction = position.direction_to(end_pos)
		position += direction*distance_traveled


func setup_initial_shot_raycast(trajectory):
	# Setting the height of the trajectory so that it is the same as LOS height
	var trajectory_with_appropriate_height = MathUtil.generate_point_at_LOS_height(trajectory)
	
	var local_trajectory = to_local(trajectory_with_appropriate_height)
	initial_shot_raycast.target_position = local_trajectory
	
	# Setting the height of the Raycast. Note we set the height of the raycast
	# rather than the actual bullet
	initial_shot_raycast.global_position.y = PhysicsConstants.HITSCAN_BULLET_HEIGHT


func fire_bullet(new_real_start_pos : Vector3, new_visual_start_pos: Vector3, trajectory, gun:Gun=null, character:Character=null):
	origin_gun = gun
	origin_character = character
	
	real_start_pos = new_real_start_pos
	visual_start_pos = new_visual_start_pos
	global_position = real_start_pos
	
	setup_initial_shot_raycast(trajectory)
	handle_hits()
	
	end_pos = generate_bullet_end_point()
	
	## Setting out position to the visual start pos to view
	## our visual travel
	global_position = new_visual_start_pos
	look_at(end_pos)
	
	fired = true


func generate_missed_bullet_endpoint():
	return to_global(initial_shot_raycast.get_target_position())


func get_shot_hit_object():
	return initial_shot_raycast.get_collider()


func generate_bullet_end_point():
	if get_shot_hit_object() != null:		
		return initial_shot_raycast.get_collision_point()
	else:
		return generate_missed_bullet_endpoint()
		

func generate_impact_for_raycast(raycast : RayCast3D, impact_particle_scene : PackedScene):
	if successful_impact_particle_scene:
		var point = raycast.get_collision_point()
		
		if point:
			var impact_particles : ImpactParticleEffect = impact_particle_scene.instantiate()
			
			Util.get_level(self).add_child(impact_particles)
			impact_particles.global_position = point
			var normal = impact_particles.to_global(raycast.get_collision_normal())
			var normal_zero_y = Vector3(normal.x, 0.0, normal.z)
			impact_particles.emit_particles_direction(normal_zero_y)


func handle_hits():
	initial_shot_raycast.force_raycast_update()
	var hit_object = get_shot_hit_object()
	
	if hit_object != null:
		# We want to deal damage to the character regardless of whether or not we hit its collision
		# box, or its projectile hit box, so we check both in that order
		if hit_object is Character or hit_object is hitbox:
			if hit_object is Character:
				RPGEventMaster.invoke_damage_event(damage, hit_object, origin_character, origin_gun, self)
			elif hit_object is hitbox:
				hit_object.deal_damage_to_character(damage, origin_character, origin_gun, self)
			
			generate_impact_for_raycast(initial_shot_raycast, successful_impact_particle_scene)
		else:
			generate_impact_for_raycast(initial_shot_raycast, unsuccessful_impact_particle_scene)



# --------- RPG Stat Effects --------- #


func apply_event_modifiers_to_event(event : RPGEvent):
	for modifier :RPGEventModifier in rpg_event_modifiers:
		modifier.apply_to_event(event)
